# 알고리즘 10주차-2

8. Graph Optimization Problems and Greedy Algorithms

2)
컨텐츠

3)
Optimiazation Problem

지금까지는 알고리즘을 수행시간을 가지고 평가했는데,
여기서는 문제 자체의 weight가 존재하게 된다.
따라서 조금 더 좋은해, 안좋은 해가 있다.

Optimiazation Problem은 최적의 해가 무엇인지 묻는 문제.

예를 들어 total cost를 최소화하기, benefit을 최대화하기 등

이런 문제를 풀 때 선택의 연속으로 이루어지는데, 선택들의 전체적인 결과가 최적이 되어야한다.

* Decision problem
항상 해를 yes or no로만 답하는 문제.

4)
Greedy algorithms
Optimiazation Problem을 해결하는 유명한 방법 중 하나

선택의 연속이 이어질 때, 각각의 선택에 대해서 그 때의 베스트의 choice를 선택하는 알고리즘
단 이 선택이 길어지면 안되고 짧은 시간내에 결정되어야한다.
또 한 번 선택하면 무를 수 없다.
따라서 그 상황에서는 가장 좋은 선택이었더라도 나중에 결과적으로는 안좋을 수 있다. 그러나 무를 수 없음.

possible drawback
따라서 그 행동이 어떤 상황에서는 가장 적은 비용이 들더라도, 나중에는 피할 수 없는 큰 비용이 들 수도 있다.
-> 이러한 경우에는 최적해를 찾을 수 없는 경우이다. 항상 그리디 알고리즘이 최적해를 찾아주는 것음 아니다.

4)
Graph Optimiazation Problem
은 그래프에 관련한 최적해 문제

어떤 최적해 문제들은 그리디 알고리즘을 사용했을 때 적절히 해결될 수 있다.

여기서 우리가 살펴볼 문제는,
- 최소의 비용으로, 즉 edge의 weight을 최소로 모든 버텍스를 연결할 수 있는 minimum spanning tree를 찾는 문제 => Prim’s 알고리즘, Kruskal’s 알고리즘
- 두 버텍스 간에 최단 경로를 찾는 문제. Sigle-Source Shortest Path => Dijkstra’s 알고리즘

5)
minimum spanning tree

spanning tree란?
spanning : 신장.
span: 걸치다. 걸쳐이어지다
-> 버텍스들을 모두 이어지게 만드는 트리

* spanning forest
G’ = (V, E’) of G ( E’  ⊆ E )
G의 버텍스는 모두 포함해야함

G가
![알고리즘 10주차-2](images/알고리즘%2010주차-2.png)

일 때

![알고리즘 10주차-2-1](images/알고리즘%2010주차-2-1.png)

![알고리즘 10주차-2-2](images/알고리즘%2010주차-2-2.png)

![알고리즘 10주차-2-3](images/알고리즘%2010주차-2-3.png)

![알고리즘 10주차-2-4](images/알고리즘%2010주차-2-4.png)

등
위는 모두 G의 spanning forest 이다.

![알고리즘 10주차-2-5](images/알고리즘%2010주차-2-5.png)

이거는 G에 포함되지 않는 edge를 가지고 있기 때문에 아님

이전의 undirected tree(free tree)의 조건은
- connected
- acyclic
- undirected

이었다.

spanning tree도 tree이기 때문에 위 조건을 만족시켜주어야한다.
역시 G의 모든 버텍스를 포함해야하고 E’  ⊆ E 이어야한다.
모든 버텍스가 커넥티드 해야하므로 m = n-1 이어야한다.

spanning tree 정의 다시.

입력 그래프 G가
![알고리즘 10주차-2-6](images/알고리즘%2010주차-2-6.png)

일 때(싸이클은 존재할 수 있음. 트리라는 조건은 없기 때문에),

스패닝 트리는
![알고리즘 10주차-2-7](images/알고리즘%2010주차-2-7.png)

를 만족해야한다. (connected 되어야하고 싸이클이 없어야함)

미니멈 스패닝 트리는(MST),
미니멈이란 말은 엣지에 가중치가 존재한 다는 뜻이므로
![알고리즘 10주차-2-8](images/알고리즘%2010주차-2-8.png)

와 같이 입력이 주어지고,
위의 스패닝 트리 조건을 다 만족하면서 그래프의 가중치가 가장 작은 경우를 말한다.
(그래프의 가중치(weight)는 모든 edge들의 가중치의 합)

![알고리즘 10주차-2-9](images/알고리즘%2010주차-2-9.png)

(a)가 입력그래프 G일 때
다음의 (b), (c), (d) 스패닝 트리를 만들어낼 수 있다.
이중에 미니멈 웨이트를 갖는 스패닝트리는 (b), (c) 이다.
따라서 미니멈 스패닝 트리는 여러개가 나올 수 있다.

6)
Prim’s Algorithm

입력으로 주어지는 그래프에서 임의로 시작 버텍스를 하나 선택 (root라고 부름)
-> 시작 버텍스를 아무거나 선택해도 미니멈 스패닝 트리를 찾을 수 있다.

시작 버텍스를 하나의 트리로 시작하여 branches out, 즉 가지를 뻗어가면서 트리의 사이즈를 점점 키워나가는 형태이다.
각 interation마다 하나의 edge를 선택하여 건너편 정점을 추가하면서 트리를 키워나간다.
트리에 엣지를 붙이는데, 붙일 수 있는 모든 엣지중에 weight가 가장 작은 엣지를 붙인다.
	-> 여기서 그리디 알고리즘 사용
그 엣지와 연결된 정점을 트리에 추가시킨다.

매 interation에서 선택시 모든 엣지중에서 minimum weight인 엣지를 찾아야하는데, 이 선택은 시간이 짧아야한다.

이 알고리즘을 수행하는동안 버텍스의 상태를 3가지로 정의
- Tree vertex : 미니멈 스패닝 트리에 포함되는 버텍스
- Fringe vertex : 트리 버텍스들에 인접한 버텍스들 -> 다음 이터레이션에서 트리 버텍스로 변경될수 있는 후보들
- Unseen vertex : 나머지 정점들. -> 최초에 모든 버텍스를 unseen으로 초기화. 시작 정점을 tree vertex로 하고 주변의 버텍스들을 fringe vertex로 바꾸어 점점 트리를 확장해나가는 형태

7)
예제를 통하여 보자

스타팅 버텍스를 A로

한 번 interation이 동작할 때마다 tree vertex의 개수가 1씩 늘어난다.

A에서는
A ->2-> B
A ->3-> G
A ->7-> F
3가지 엣지가 있는데 가장 w가 작은 엣지는 2이므로 B가 트리노드가 된다

그이후에 Fringe노드는 늘어나게되는데,
B->4->C
B->6->G
을 갈 수 있게 된다.

이 때 G로 가는 길이 2개인데 이중에서 w가 가장 작은거만 남기고, 나머지는 없앤다.
즉 A->3->G는 남기고, B->6->G는 없애게된다.

그 이후도 마찬가지.

구현단에서 한 번 살펴보자.
정점에 대한 2개의 배열을 만든다.
거리에 대한 배열, state에 대한 배열

최초 초기화 상태
![알고리즘 10주차-2-10](images/알고리즘%2010주차-2-10.png)

A를 스타팅 노드로 지정이후 
![알고리즘 10주차-2-11](images/알고리즘%2010주차-2-11.png)

다음과 같이 업데이트

그다음 이터레이션 -> B를 tree vertex로(F중 최소 D)
![알고리즘 10주차-2-12](images/알고리즘%2010주차-2-12.png)

그다음 이터레이션 -> G를 tree vertex로(F중 최소 D)
![알고리즘 10주차-2-13](images/알고리즘%2010주차-2-13.png)

그다음 이터레이션 -> I를 tree vertex로(F중 최소 D)
![알고리즘 10주차-2-14](images/알고리즘%2010주차-2-14.png)

이 때 F에 대해서, 새로 발견된 edge가 더 weight가 작으므로 업데이트

그 이후도 마찬가지 

여기서 핵심적인 사한
Fringe 정점들 중에서 edge의 weight가 최소인 것을 어떻게 찾을까?
-> min-PQ를 이용한다.

PQ를 구현하는 3가지 방법이 있었다.
- sorted sequence
- unsorted sequence
- heap(binary heap)

![알고리즘 10주차-2-15](images/알고리즘%2010주차-2-15.png)

decreasekey는 새로운 fringe 정점들이 추가 되었을 때, 특정 정점으로 가는 엣지의 weight를 업데이트시켜주는 함수.
sorted 에서는 이미 배열에 weight 순으로 정렬되어있기 때문에, update시키려면 최악의 경우 배열 전체를 탐색해야한다 -> O(n)
unsorted에서는 특정 인덱스에 바로 접근하여 값을 업데이트 시켜주면 되기 때문에 상수시간. -> O(1)
heap에서는 각 노드에 배열의 특정 주소를 담아놓으면 되지만, 업데이트 시키고 힙의 구조를 만족시켜주기위해 upheap을 하는데, 최악의 경우 root까지 갈 수 있으므로 -> O(log n)x	

8)
이 수행시간에 따라 시간 복잡도를 분석해보자.
![알고리즘 10주차-2-16](images/알고리즘%2010주차-2-16.png)

insert와 removeMin은 무조건 모두 n번 수행  = 2n번-> O(n)
decreasekey는 2m번 만큼 수행(undirected graph라서 같은 엣지가 다른 정점 2개에 의해 2번 탐색됨 -> O(m) time

따라서
![알고리즘 10주차-2-17](images/알고리즘%2010주차-2-17.png)

(sorted는 성능이 나쁘므로 x)

그래프가 sparse ->
![알고리즘 10주차-2-18](images/알고리즘%2010주차-2-18.png)

=> 힙이 유리

그래프가 dense ->
![알고리즘 10주차-2-19](images/알고리즘%2010주차-2-19.png)

=> unsorted가 유리

