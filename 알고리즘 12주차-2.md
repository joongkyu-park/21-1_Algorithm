# 알고리즘 12주차-2

9)
step3. 점화식을 이용하여 재귀/반복 적으로 계산

본 강의에서는 바텀업으로 계산한다.

인풋 : 각 행렬 대신에, 행렬에 대한 차원들의 정보를 넣어줘도 된다.
![알고리즘 12주차-2](images/알고리즘%2012주차-2.png)

![알고리즘 12주차-2-1](images/알고리즘%2012주차-2-1.png)

이 인풋으로 value of optimal solution과 (m 테이블)
optimal solution(s 테이블)을 구할 수 있다.

10)
의사코드 예시

의사코드 설명은 생략하고 뒤의 예시로 설명하겠다

11)
예시.
A1~A4의 행렬.
각 차원에 대한 정보.
![알고리즘 12주차-2-2](images/알고리즘%2012주차-2-2.png)

m테이블의 대각선 값을 0으로 초기화
왜냐하면
![알고리즘 12주차-2-3](images/알고리즘%2012주차-2-3.png)

인데 행렬이 한개가 있을경우이므로, 최소곱셈연산수는 0이라고 했으니까.

바텀업 방식이므로 작은 크기의 서브프로블럼부터 점점 커져서 오리지널 프로블롬을 해결하는 형태로 진행. -> matrix chain의 길이로.
행렬이 1개있을 때 matrix chain의 길이 l를 1, 2개있을 때 2라고 … 생각.
l이 1인경우는 위와같이 행렬이 1개 있는 경우이므로 제일먼저 초기화한것
따라서 다음과같은 순서로 계산 진행
![알고리즘 12주차-2-4](images/알고리즘%2012주차-2-4.png)

여기는 따로 계산할 일이 없다. 범위가 거꾸로가 되기 때문에(A2부터 A1까지…?)
![알고리즘 12주차-2-5](images/알고리즘%2012주차-2-5.png)

s테이블은 대각선을 포함해서 아래쪽을 사용하지않는다.
대각선을 사용하지않는 이유는, 대각선은 행렬이 1개이기 때문에, matrix chain을 2개이상으로 쪼갤수없기 때문에 k를 구할 수 없다.
![알고리즘 12주차-2-6](images/알고리즘%2012주차-2-6.png)

m[1,2]부터 계산해보자.
![알고리즘 12주차-2-7](images/알고리즘%2012주차-2-7.png)

⭐️시험에 나왔을 때는 경우의수가 1개라도 min 1<= k < 2 이런 범위를 잘써줘야한다!
![알고리즘 12주차-2-8](images/알고리즘%2012주차-2-8.png)

그때의 k값은 쪼갤 수 있는 경우의수가 k=1 한개 밖에 없기 때문에
![알고리즘 12주차-2-9](images/알고리즘%2012주차-2-9.png)

다음 m[2, 3]

![알고리즘 12주차-2-10](images/알고리즘%2012주차-2-10.png)

![알고리즘 12주차-2-11](images/알고리즘%2012주차-2-11.png)

다음 m[3, 4]
![알고리즘 12주차-2-12](images/알고리즘%2012주차-2-12.png)

![알고리즘 12주차-2-13](images/알고리즘%2012주차-2-13.png)

이제 l =3인경우를 계산해보자

m[1, 3]
![알고리즘 12주차-2-14](images/알고리즘%2012주차-2-14.png)

l=2 보다 작은 크기의 값들은 이미 계산이 되어있다. => 바텀업.
따라서 테이블에서 그냥 가져다가 쓰면 된다.

![알고리즘 12주차-2-15](images/알고리즘%2012주차-2-15.png)

m[2,4]
![알고리즘 12주차-2-16](images/알고리즘%2012주차-2-16.png)

![알고리즘 12주차-2-17](images/알고리즘%2012주차-2-17.png)

l=4인 마지막케이스
m[1,4]
![알고리즘 12주차-2-18](images/알고리즘%2012주차-2-18.png)

이렇게 m테이블과 s테이블을 완성시킬 수 있다.
![알고리즘 12주차-2-19](images/알고리즘%2012주차-2-19.png)

스텝3에 대한 시간복잡도를 분석해보자
m 테이블을 봤을 때
l=1 인경우 -> n개
l=2 인경우 -> n-1개
…
l=n 인경우 -> 1개
이만큼 셀의 개수에 대해 계산을 해야한다.
즉 1+2+…+n -> O(n^2)

하나의 셀을 계산하는 경우는 최악의경우 O(n)타임.
그러한 셀이 O(n^2)개가 존재하기 때문에

따라서, 이 알고리즘은 O(n^3) time이 된다.

space는 n^2만큼 테이블을 사용하니까 O(n^2) space이다.
![알고리즘 12주차-2-20](images/알고리즘%2012주차-2-20.png)

12)
스텝4. s테이블이용해서 optimal solution 계산

s테이블만 있으면 곱셈순서를 알 수 있다.
![알고리즘 12주차-2-21](images/알고리즘%2012주차-2-21.png)

s테이블이 이렇게 입력으로 주어진다.

의사코드는 알아서 한번 보보고, 개념적으로 설명하겠다.
재귀로 계산하기 때문에 바이너리트리를 이용해서 계산해줄 수 있다. 
i=j될때까지

inorder travesal처럼 출력해주면 된다.
![알고리즘 12주차-2-22](images/알고리즘%2012주차-2-22.png)

