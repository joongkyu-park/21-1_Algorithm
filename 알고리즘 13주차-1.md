# 알고리즘 13주차-1

1. String Matching

2)
다른 말로 패턴 매칭이라고도 한다.

- 부르트 포스 알고리즘(= navie 알골지ㅡㅁ)
- KMP 알고리즘
- Boyer-Moore 알고리즘

입력으로 두가지가 주어진다.
긴 문자열(Text), 짧은 문자열(pattern)
텍스트에서 패턴이 발생하는 위치를 찾는것

아래의 두 알고리즘은 빠르게 수행하기위해
패턴에 대해서 전처리(Preprocessing)을 진행한다.

우리가 워드같은에서 쓰는 ctrl + f도  string matching 알고리즘을 이용

text에 대해서 전처리를 하는 것도 있지만, 문자열을 전공해야 알 수 있다.
예를 들어 검색엔진에서, 방대한 자료속에서 패턴을 찾으려면 text에 대해 전처리가 필요할 것이다

3)
용어.
String
c++에서 사용하는 string과 거의 같다

- 0개 이상의 character의 나열이다. character가 0개라면, empty string이라고 부른다. 0개의 character로 구성된 string.
- 여러예시 - c++ 프로그램 소스 코드 자체도. 뭐 컴파일된 목적파일도 스트링이라고 볼 수 있고. - HTML으로 작성된 문서 - DNA 염기서열 {A, C, G, T} ACCGGTT … 이런식으로 구성된 이중나선 만약 텍스트파일로 생성한다면 30억개의 염기가 있고 character 1개당 1Byte라고 하면 약 3GB의 text file로 나타낼 수 있다 - Digitized된 이미지 파일. 0과 1로 구성된 파일이니까.
- 문자열 매칭에서 알파벳이라는 개념이 있다. 알파벳은 대부분의 경우 시그마 기호를 이용해서 나타낸다. 수열에서의 합과 다른 표현. 여기서의 _∑__는_ 어떤 스트링(텍스트나 패턴)에서 나올 수 있는 character의 집합
- 알파벳 예시 예를 들어 알파벳이 {0,1}이면 입력으로 주어지는 텍스트나 패턴은 0, 1으로만 이루어져있다는 뜻 대표적인 알파벳 {0, 1} : binary alphabet {A, C, G, T} : DNA alphabet  알파벳의 수에 따라 알고리즘의 성능이 달라질 수 있다. 이건 디ㅜ에서

4)
- 문자열 P의 길이가 m이다 -> character의 개수가 m개이다. - substring(부분문자열) string P에서 임의의 연속된 character들의 나열 ex) P = “algorithm” -> 9개의 character로 구성. m=9 서브스트링의 예시 “m”, “gori” … 즉 P에서 임의의 i번째 인덱스부터 j번째 인덱스까지의 캐릭터들의 나열을 서브스트링이라고 말한다. (당연히 0<= i, j <= m-1) 만약 j < i 이면, empty string이라고 한다.  2개의 특별한 서브스트링 - prefix 접두사. 시작 인덱스가 0으로 고정되어있는 서브스트링 ex) “a”, “al”, “alg”, “algorithm” …  - suffix 접미사. 끝 인덱스가 마지막(m-1)으로 고정되어있는 서브스트링 ex) “m”, “hm”, “thm”, “algorithm” …  +) proper substring, proper prefix -… > 진 부분문자열, 진 접두사 라고 한다. 모두 자기자신(여기서 “algorithm”)을 제외한 부분집합들을 의미
- 입력으로 T(text), P(pattern) 2가지가 주어지고 T에서 P와 동일한 서브스트링을 찾는 문제. 원래는 모든 서브스트링을 찾아야하는데, 해당 교재에서는 1번만 찾으면 알고리즘이 종료하도록 되어있다.
- 응용되는 분야들

5)
Pattern matching 알고리즘을 해결하는 알고리즘들.

Brute-Force 알고리즘
가장 단순한 방법.

텍스트 T에서 패턴 P를 찾기위해, 모든 가능한 비교를 다한다. T에 P가 있다면, T에 P가 발생하는 위치의 인덱스를, 없다면 -1를 반환
T에 있는 모든 P의 위치

6)
단순함
T : n size
P : m size

T의 0번째 위치부터 P와 대조하면서 하나하나 비교.
P와 비교하다가 다른부분이 있으면 다음 인덱스.
ex) T : “algorithm”, P : “goto”
i=0
T[0] 와 P[0]가 다르므로 다음 루프
i=1
다르브로 다음루프
i=2
T[2] == P[2] == g이므로 다음거 확인
T[3] == P[3] == o이므로 다음거 확인 
	-> 이런식으로 확인하다가 패턴과 같은 부분이 있다면, j=m이 되겠고, 그때의 i를 리턴
T[4]와 P[4]가 다므로 다음 루프

…
이런식으로 i = n-m까지

7)
수행시간 분석
최악의 경우 O(nm)타임
T의 임의의 인덱스 i에 대해서 최악의 경우 m번 비교해야하고,
T는 O(n)의 길이이기 때문에
	-> O(nm) time 이라고 할 수 있다.

이와같은 최악의경우는 이미지파일(0, 1)이나 DNA 서열(A,C,G,T)에서 발생할 가능성이 높다. (알파벳 집합의 원소가 적은 것들)
알파벳이 큰 english text같은 경우는 나올 수 있는 캐릭터의  종류가 다양하기 때문에 왠만하면 중간에서 mismatch가 발생할 것이다.

어떤 실험에서 english text같은 경우는 거의 O(n) time에 가깝다고 말한다.
이 알고리즘이 각 T[i]에 대해 약 1.1 character의 비교를 수행한다고 알려져있음.
따라서 english text같은 경우 왠만하면 mismatch가 빨리 발생해서 최악의 경우까지 가기가 드물다.

8)
한편, 브루트 포스 알고리즘은 character by character 비교를 하기 때문에 굳이 또 비교할 필요없는 캐릭터를 비교하는 경우도 발생한다.
KMP알고리즘은 불필요한 캐릭터의 비교를 줄이는 효율적인 알고리즘이다.
브루트 포스는 무조건 1칸씩 이동했다면, KMP는 중복비교를 피해서 여러칸을 shift하게된다.
역시나 left to right로 움직이는 건 같다.
즉 mismatch가 발견되었을 때 중복비교를 피하기위해 얼만큼 shift를 할 수 있을까.

 P와 T가 어느정도 매칭이 되었다면,
그 매P의 가장큰 prefix( P[0..j]

9)
예를 들어보자

노란색부분 : 캐릭터 바이 캐릭터로 비교했을 때 매칭되는 부븐
파란색부분 : mismatch가 발생하는 부분

노란색부분(즉 매칭된부분)은 P의 prefix인 셈인데,
그 노란색부분에서의 proper prefix와, 노란색부분에서의 proper suffix가 같은 크기로 최대 매칭되는 부분을 찾는다.
교재의 노란색부분은 현재 “abaab”인데, 앞쪽 ab와 뒤쪽 ab가 최대매칭 되는 부분임을 알 수 있다.(그 전으로는 a/b, 그다음으로는 aba/aab, abaa/baab 가 있는데 다 같지 않으므로 안되고, proper prefix/suffix만 고려하기때문에 ab가 최대.)

그렇게 해서, 그 매칭되는 부분을 이용해서 shift의 크기를 1이상으로 할 수 있게 된다. 또 위에서의 ab는, 이전 루프에서 T와 매칭되는걸 알기 때문에 굳이 비교해주지않고 그 다음번 캐릭터부터 비교하게 된다.

이러한 과정을 진행하기 위해,
얼마큼 shift를 해야하는지, 또 다음에 비교할 패턴의 index는 어떻게 되는지 알기 위해
패턴에 대해 preprocessing을 해주어야한다

10)
패턴을 preprocessing한 정보를 failure function이라고 부른다.
array로써 failure function을 계산하게 된다.

개념먼저.
값의 의미
![알고리즘 13주차-1](images/알고리즘%2013주차-1.png)

F(j) : P의 j번째 까지 프리픽스에서 가장 일치하는 proper prefix와 proper suffix의 길이를 나타낸다.
F(0)같은 경우는 a 하나인데, proper이어야하므로 a를 빼버리면 empty string이 되므로 무조건 0이 되겠다.

![알고리즘 13주차-1-1](images/알고리즘%2013주차-1-1.png)

위와같이 failure function의 index j가 0부터 시작하면 다음과 같은 특징을 가진다.
위에서 보면 노란색부분이 매칭된다고했을때 P에서 0번째 인덱스부터 시작해서4번째 인덱스 까지 매칭되고 5번째 인덱스에서 mismatch가 발생한다.
T의 입징에서는 i가 1씩 증가하다가 T[i]가 x일때 mismatch가 발생하게 된다
이 때 P에서는 F(4)의 값을 이용한다. F(4) = 2 인데, 이 2는 다음번에 비교를 시작하는 P에서의 인덱스가 된다.

이는 function의 array의 Index가 0부터 시작할 때 가지는 특징이다.

또 이 때 i의 값은 이전의 i값(mismatch가 발생했던 부분)과 동일하다.

즉 우리가 그림으로보는 shift라는 것은 실제로 j=5 -> j=2로 바뀌는 것이고,
i는 동일한 상태인 것이다.

