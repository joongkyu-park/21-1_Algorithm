# 알고리즘 13주차-2

10)
KMP 알고리즘 계속

KMP 알고리즘과 브루트 포스 알고리즘의 차이점

T의 인덱스를 i 하나로만 표현한다고 할 때,
브루트 포스는 mismatch가 발생했을 때 다음과 같이 i 값이 감소하게 된다.

KMP 알고리즘 경우는 i값이 감소하지 않고 일정하게 된다.
![알고리즘 13주차-2](images/알고리즘%2013주차-2.png)

11)
KMP 알고리즘의 수행시간

텍스트의 길이를 n, 패턴의 길이를 m이라고 했을 때
failure function은 O(m)시간에 계산할 수 있다. (Preprocessing)
계산한 값을 F라는 array에 저장

i는 text T에 대한 인덱스
j는 pattern P에 대한 인덱스

while loop는 i < n 일 때 동작.
![알고리즘 13주차-2-1](images/알고리즘%2013주차-2-1.png)

왜냐하면 위 그림과 같이 i는 n-1까지 갈 수 있기 때문

i를 기준으로 알고리즘의 복잡도를 분석

i가 증가하는 케이스 -> if, else
	-> i에 대해 n번 interation을 수행
i가 증가하지 않는 케이스 -> else if 
	-> 추가적인 ⍺번 필요

또,
![알고리즘 13주차-2-2](images/알고리즘%2013주차-2-2.png)

이렇게 match / mismatch 케이스로 구분할 수 있다.

일단 캐릭터 바이 캐릭터를 비교했을 때, 일치하면
i와 j값을 하나씩 증가시키면서 다음 캐릭터를 비교.
그렇게 하다가 패턴의 마지막 까지 일치했다면, 텍스트의 서브스트링의 시작위치(i-j)를 리턴해준다.

mismatch가 발생할경우 두 케이스에 대해 수행해준다
j>0인 케이스.
	-> 텍스트와 패턴이 어느정도 일치했다는 것을 의미.
-> failure function을 이용

j=0인 케이스.
	-> 맨 처음 캐릭터부터 mismatch
-> 단순히 텍스트 인덱스인 i를 하나 증가

수행시간 분석
i가 증가하는 케이스에서, i로 인해서 iteration은 총 n번 수행되고,
i가 증가하지 않는 케이스에서, 총 ⍺번 수행된다고 했는데
	-> 패턴이 오른쪽으로 shift하는 케이스
그럼 얼마만큼 shift 할 수 있느냐. shift하는 회수를 따져 보면 된다.
패턴이 아무리 많이 shift해봤자 text의 길이만큼 shift할 수 있다. 많이해봐야 n번.
따라서 +⍺번은 많아봐야 n번이다

따라서 while루프 전체는 최악의경우 총 2n번이므로 -> O(n) 시간

따라서 총 preprocessing 까지 더하면 최악의경우에 대해 O(n+m)시간으로 linear 타임에 수행하게 된다.

12)
Failure function을 계산하는 방법
-> searching에서 계산하는 알고리즘과 거의 같은 구조로 계산하게 된다.

의사코드가 아닌 예씨로 살펴보겠다.

P = “a b a b a a b”
일 때 F의 값을 계산해보자

… * 이 과정 다시 보기 * ….

위 과정으로 인하여 서칭알고리즘 과같이 while 루프가 최대 2m번이므로, O(m) 시간에 바운드된다.

13)
예시

나타나있는 숫자는 비교하는 연산순서.

+)
그림에서 j=5인경우, 즉 다 매치되었을 경우는 언제 사용하냐.
다 매치가 되고 그다음번 비교를 위해사용.
우리 교재에서는 최초 1회 패턴과 똑같은 서브스트링을 찾으면 알고리즘을 종료하는데,
원래 스트링 매칭은 패턴과 같은 모든 서브스트링을 찾기 때문에 그 때 이용

14)
Boyer-Moore Heuristics
보여-모어 알고리즘

강의에서 배우는 알고리즘은 오리지널 보여-모어 알고리즘이 아닌,
보여-모어 알고리즘의 한 variation 버전이다.

크게 2가지 heuristic 전략을 사용한다.
heuristic이란?
인공지능 분야에서 나온 단어.
전체 최적의 해를 global optimal이라고 부르는데, 그 것을 얻는게 상당히 오랜시간이 걸릴 수 있다.
그때 수행시간을 빠르게 처리하면서,  대신에 항상 global optimal한 soultion을 얻는 것은 보장하지못하지만 최소한 local optimal 해를 계산하는 알고리즘을 말한다. 운이 좋으면 local optimal 해가 global optimal 해가 될 수 있다.
보여모어 알고리즘의 최악의 수행시간은 느리다. 그러나 일반적인 인풋들에 대해 빠르게 수행가능하다.

첫 번째 heuristic
- Looking-glass heuristic : 거꾸로의, 반대의. T의 서브스트링과 패턴을 비교할때 왼쪽->오른쪽이아닌 오른쪽->왼쪽 순서로 비교한다.
- Character-jump heuristic Looking-glass heuristic 을 사용하다 mismatch 가 발생했을때 패턴을 얼마만큼 shift 시킬 것인가. 텍스트의 캐릭터를 기준으로 shift 하게 된다. 그 때의 캐릭터를 T[i] = c를 기준으로 시프트. 그 캐릭터가 패턴에 포함되는 경우 / 포함되지 않는 경우로 나눌 수 있다. 캐릭터가 패턴내에 존재하는 경우 -> 그 패턴의 캐릭터와, 텍스트의 캐릭터가 같기 때문에 align하게 되도록 shift 해준다. 캐릭터가 패턴에 존재하지않는 경우 -> 패턴이 발생할 일이 없기때문에, 패턴의 길이만 큼 shift

교재의 아래의 예시의 숫자는 연산순서.

14)
보여-모어 알고리즘에서 얼마만큼 shift할 수 있느냐를 알기위해서는,
각 캐릭터가 발생하는 마지막 위치를 알고 있어야한다.
![알고리즘 13주차-2-3](images/알고리즘%2013주차-2-3.png)

만약 다음과 같을때, P[0]에 align하는게 아니라, 마지막 t인 P[2]에 align 시켜야한다.

어떤 캐릭터가 입력으로 주어질지 모르기 때문에,
Last-Occurrence Function은 모든 발생할 수 있는 캐릭터에 대해 다 계산을 해줘야한다.

스트링에서 나올 수 있는 문자들의 집합을 알파벳이라고 했고 시그마를 이용하여 표기한다고 했다.

이 예시에서는 알파벳이  {a,b,c,d}로 구성된다고 가정.
그럼 텍스트나 패턴 모두 나올 수 있는 캐릭터가 알파벳 내에서 나올 수 있다.

모여-모어 알고리즘의 Last-Occurrence Function은 알파벳의 크기만큼의 array로 표현된다.

스몰 시그마는 라지 시그마(알파벳)의 원소를 나타낸다.

교재와 같이 인덱스가 스몰시그마(문자)로 나와있는데 배열은 원래 인덱스가 정수여야한다.
그러나 쉽게 계산 가능하기때문에, 그냥 문자로 쓴다
( 
![알고리즘 13주차-2-4](images/알고리즘%2013주차-2-4.png)

이렇게 할 경우 원하는 인덱스 정수를 얻을 수 있다.)

Last-Occurrence Function의 어레이의 사이즈는 시그마의 사이즈만큼 할당해주고,
모든 캐릭터에 대해 -1로 초기화한다.

![알고리즘 13주차-2-5](images/알고리즘%2013주차-2-5.png)

패턴을 왼쪽에서부터 오른쪽으로 스캔하면서 캐릭터들이 발생하는 인덱스를 업데이트 시켜준다.

P=abcab이므로, 
![알고리즘 13주차-2-6](images/알고리즘%2013주차-2-6.png)

다음과 같이 되겠다.
-1인건 해당 캐릭터가 패턴에서 발생하지 않음을 의미

따라서 -1로 초기화하는데 -> O(s) (어레이 크기만큼)
업데이트 시키는데 패턴의 길이만큼 이므로 -> O(m)

따라서 preprocessing 하는데 총 O(m+s)의 시간이 걸린다

15)
보여-모어 알고리즘의 전반적인 의사코드

Looking-glass heuristic이므로 i와 j를 m-1로 초기화

mismatch가 발생하는 경우는 크게 2가지로 나눌 수 있다

case1.
오른쪽부터 캐릭터 바이 캐릭터를 비교하다가 mismatch가 발생된 경우,
mismatch가 발생된 패턴의 지점을 기준으로, 텍스트의 캐릭터와 일치하는 패턴의 캐릭터가 오른쪽에 있는 경우, Last-Occurrence Function을 이용할 수 없는 케이스다.
왜냐하면, 예시에서 패턴의 맨 마지막 캐릭터인 a를 텍스트의 a와 align 시키면 패턴이 왼쪽으로 쉬프트 하게 되므로.
따라서 이경우에는 오히려 역순으로 진행되기 때문에, 단순히 패턴을 오른쪽으로 한칸만 쉬프트를 한다.

case2.
Last-Occurrence Function을 이용할 수 있다.
mismatch가 발생했을때, text의 i번째인 a에 대한 last occurence가 상대적으로 왼쪽에 있을 경우, 패턴의 a을 text의 i번째 a와 align하도록 쉬프트 시킨다.

한편,
패턴을 쉬프트 한다는 것은, 개념적으로 봤을 때 패턴를 쉬프트하는 것처럼 보이는 것.
알고리즘에선 패턴이 쉬프트 한다 이런게 없음. 그냥 인덱스를 업데이트하면서  캐릭터 바이 캐릭터를 비교하는 것이기 때문에 실제로 알고리즘을 적용할 때는 i값이 증가하게 된다.
j는 항상 마지막위치값인 m-1로 업데이트 되고,
i값이 얼만큼 쉬프트하냐, 이것에 의해 계산이 된다.
그 때 i가 증가하는 값이 각각 m - j 또는 m - (1 + l) 값만큼 증가하게 된다.
m : 패턴의 길이
j : 미스매치가 발생한 패턴의 인덱스
 
![알고리즘 13주차-2-7](images/알고리즘%2013주차-2-7.png)

16)
보여-모어 알고리즘 예시

숫자는 캐릭터 바이 캐릭터를 비교하는 순서이다.

6번째 비교 때 d는 존재하지 않기 때문에 패턴의 길이만큼 shift

17)
수행시간 분석

워스트케이스에서는 상당히 느린 시간을 갖는다.
교재의 예시가 워스트케이스 예시.
브루트 포스와 거의 유사하게 동장
-> O(nm + s)시간이 걸리게 된다. s는 preprocessing 시간, nm은 searching 시간

이러한 최악의경우는 image(바이너리로 구성) 또는 DNA같이 알파벳 집합이 작을 때 나타날 수 있다.

그러나 알파벳의 사이즈가 큰 경우, 즉 대부분의 인풋에 대해서는 브루트-포스보다 훨씬 더 빠르게 수행.

KMP랑 비교해서도,
같은 예시에서 KMP는 19번의 비교연산을 했는데
보여-모어는 13번의 비교연산을 했다.

따라서 대부분의 인풋에 대해서는 보여-모어 알고리즘이 일반적으로 빠르다.

그래서 텍스트에디터의 ctrl + f같은 것도 대부분 보여-모어 알고리즘에 기반한다

추가설명+)
![알고리즘 13주차-2-8](images/알고리즘%2013주차-2-8.png)

mismatch가 발생했을 때, 텍스트에 있는 캐릭터 T[i] = c를 ‘bad-character’라고 부른다.
따라서 bad-character를 이용하여 shift한다고 해서, 대부분의 곳에서는 Character-jump heuristic이 아닌 bad-character heuristic이라고 부른다.

