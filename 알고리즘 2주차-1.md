# 알고리즘 2주차-1

지난시간 복습
basic operation을 찾지 못하면 자료구조때 처럼primitive operaition을 세도되지만..
그래도 기본연산인 basic operation을 찾자,,

16)
알고리즘을 고를때,
- correcteness 확인하고
- amount of work done -> time complexity(시간복잡도)와 space used -> space complexity(공간복잡도) 분석
- optimality분석(알고리즘의 수행시간과 문제의복잡도가 같은지 확인) simplicity(알고리즘의 의사코드를 좀 더 간결하게, 복잡도가 같더라고 불필요한 연산들 제거)

17)
Correctness도 증명을 통해 검증

input이 output으로 정확하게 변환하는지 검증

preconditions : 인풋데이터의 상태. 해결하고자하는 문제의 인풋 조건에 만족하는지
postconditions : 아웃풋데이터의 상태. 알고리즘이 종료되었을 때 아웃풋데이터가 그 조건에 만족하는지

18)
시간복잡도는, 그 알고리즘이 수행하는 일의 양을 측정

알고리즘을 이론적으로 분석하기때문에 컴퓨터의 사양, 프로그래밍언어, 프로그래머의 능력, 여러 디테일들에 대해 독립적으로 측정
일의 양을 측정할 때는 인풋사이즈(n)에 대해 분석을 한다.

basic operation
그 문제에서 수행하는 가장 기본적인 오퍼레이션 선택
정확하게 하나하나 비교할필요없지만, 
roughly하게 베이직오퍼레이션의 최대개수를 분석을 하여 시간복잡도를 분석한다
ex) n이 선형적으로 비례, 제곱에 비례… 등

인풋의 프로퍼티에 따라 최악수행시간이 달라질 수 있다.
ex)어떤 정렬알고리즘에서, 이미 인풋이 정렬되어다면.. 달라질 수 있다.
=> 따라서 인풋의 프로퍼티를 정확히 파악해야한다

19)
가장 기본적인 분석방법, worst-case analysis

Dn : 해당문제에서 주어질수있는 모든 가능한 인풋들의 집합.
I : Dn안의 특정 인풋

t(I) : I에서 수행하는 베이직 오퍼레이션의 수를 카운트

최대수행시간분석
W(n) : Dn이 특정 인풋(다양한 인풋) I에 대해서, 
	그 알고리즘이 수행하는 t(I)(베이직오퍼레이션 개수) 중에서 최대인것.

=> _사이즈가 n_인 임의의 인풋에 대해서 알고리즘이 수행하는

베이직 오퍼레이션의 최대개수를 의미한다.

인풋의 프로퍼티에 따라 우리가 선택해야하는 알고리즘이 달라질 수 있다.

20)
워스트케이스가아닌 average-case analysis

최악수행시간분석은, 어떤 알고리즘을 분석할 때 반드시 필요하지만
평균케이스분석은 하면 좋지만, 필수는 아니다.
최악수행시간은 느리지만 평균수행시간은 빠른 알고리즘도 있다 ex) 자료구조때 해싱기법

확률적으로 분석하게 된다.
Pr(I) : 특정인풋 I에 대해, I가 발생할 확률
이거도 베이직 오퍼레이션을 이용한다.
확률적으로 베이직 오퍼레이션을 얼마나 사용하느냐.
A(n) : 인풋으로 들어온 n의 사이즈에 대해서 나타냄.
	
t(I)는 알고리즘에 나와있는 의사코드를 분석함으로써 얻어낼 수 있다.
그러나 Pr(I)에 대해서는 분석적으로 할 수 없다. 경험적, 통계적으로 계산해야함.
대부분의 경우에 그런 통계치가없어서, 모든 확률은 동일하다라고 간단하게 증명하는 경우가 많다,

21)
예시

22)
이때의 average case를 알아보자.
탐색이 성공할때의 케이스(k가 어레이에 존재하는경우), 실패할경우를 나누어 분석

- 탐색이 성공하는 케이스 : Pr(succ)Asucc(n) 토탈케이스 n+1 성공하는케이스가 n개, 실패하는케이스 1개  인덱스 0에서 k를찾는 경우, 1에서찾는경우 , i에서 찾는경우.. -> 모두 같다고 생각. => 성공할때의 확률은 1/n로 동일하다고 가정 Pr( Ii l succ) : 탐색이성공했을 때의 확률  성공할때의 평균수행시간은 다음과 같이 작성한다. ** i는 인덱스범위 의미. 0부터 n-1 까지!! 주의  t(Ii) : 비교연산(베이직 오퍼레이션) = i+1 (인덱스 + 1)  .. 탐색이 성공할때 평균수행시간 => (n+1)/2
- 탐색이 실패하는 케이스 : Pr(fail)Afail(n) 실패할때는, 경우가 1가지 케이스. 어떤 인풋이 들어오더라도 인풋이 배열안에 존재하지 않는 경우 t(I) = n : 모든 엘리먼트와 k를 비교해야하기때문

탐색자체가 성공할것이냐, 의 확률은 q로 표현.
성공할때의 확률 : q, 실패할때 : q-1
q는 경험적으로 얻는다.
항상성공한다고 가정 -> q=1, A(n) = (n+1)/2 : 대략 절반정도의 비교연산을 했으면 성공한다
절반의 확률로 성공 -> q=1/2, A(n) = (n+1)/4 + n/2 = (3n+1)/4 : 확률이 반반이 경우에는, 3/4n 정도의 비교연산을 하면 탐색을 성공하거나 실패하거나 알 수 있다. (최고차항이중요)

23)
공간복잡도에서 분석해보자, 그리고 simplicity

알고리즘이 사용하는 스페이스의 양을 계산, 인풋사이즈 n에 대해

대부분의 알고리즘의 경우 time과 space가 tradeoff인 관계가 많다.

simplicity는 미덕이다..!
의사코드가 간결하면 장점
- 알고리즘의 correctness에 대한 증명을 더 쉽게할 수 있다.
- 알고리즘의 구현, 디버깅, 수정을 더 쉽게할 수 있다.

따라서 simplicity도 중요하다!

24)
optimality
모든 문제는 그 문제만의 복잡도를 가지고 있다. 고유한 복잡도.
그 문제를 해결하기위한 최소한의 일의양.

알고리즘의 클래스, 즉 베이직 오퍼레이션을 먼저 선택하고
그 문제를 해결하기 위한 최소 베이직 오퍼레이션의 개수를 세면
그 문제를 해결하기위한 최소 일의 양을 구할 수 있다.

알고리즘의 복잡도와 문제의 복잡도가 동일하면 optimal하다.

the best known : 지금까지 알려진 알고리즘중 가장 빠른 것
the best possible : 어떤 알고리즘도 문제의 복잡도보다 더 빠를 순없다. 점근적으로는 더 빠른 알고리즘이 존재하지않는다. 				물론 앞의 계수가 달라질 순 있다.
				문제의 복잡도 = 알고리즘의 복잡도인 경우(점근적으로 같다는뜻)

