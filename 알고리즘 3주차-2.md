# 알고리즘 3주차-2

44)
C 방법보다 더 개선할 수 있는 방법은 없을까?!

strategy D
인풋이 정렬된 상태로 주어졌기 때문에, binary search를 이용할 수 있다.
기본전략 : 앞에서부터가아니라, 찾고자하는 K값과 가운데 값과 먼저 비교한다.
해당 엘리먼트가 K보다 작으면 오른쪽에 있을거고, 크면 왼쪽에 있을것이다.
-> 가운데 값과 비교하면, 그 이후에는 나머지 절반과는 비교할필요없다. 절반의 원소제거가능/
이것을 반복하는게 이진탐색의 전략.

알고리즘을 살펴보자.
입력으로는 정렬된 어레이 E를 받아야하고,
알고리즘을 수행함에 있어서 first, last라는 변수를 정의해준다.
first와 last는 찾고자하는 범위의 첫번째와 마지막 인덱스(처음엔 0, n-1)
바이너리서치는 재귀적으로 수행된다. K는 우리가 찾고싶은 키값
아웃풋은 마찬가지. K값이 있다면 해당 인덱스, 없으면 -1

이진탐색의 주의할점.
1. 배열사용해야함 -> 임의의 인덱스에 상수시간에 접근해야하기 때문
2. 정렬된상태 만족 해야함-> 절반의영역 제거가능

45)
바이너리서치 알고리즘
입력으로 배열 E, 2개의 인덱스 first와 last, 찾고자하는 키값 K
아웃풋은 성공하면 인덱스, 실패하면 -1

1~2 라인 : last < first -> 비교할영역이없는경우, 실패.

3~11 라인 : 탐색 진행
재귀함수형태. (재귀가 아니더라도 반복문 형태로 구현가능)

46)
이진탐색알고리즘의 복잡도
워스트케이스, 에버리지케이스 분석.
그리고 optimaility.

worst case.
베이직 오퍼레이션 : 키값 K와 배열 엘리먼트간의 비교연산.
베이직 오프레이션을 선택할 때 주의사항
-> 의사코드만 보고 결정하는 것이아니라, 알고리즘의 개념적으로, 논리적으로 사용하는 연산이 무엇이냐.
비교연산이라고 무조건 베이직오퍼레이션이라고 카운트 하는게 아님.
예를 들어 1번 라인의 있는 last와 first, 두 인덱스의 비교는 베이직오퍼레이션 사용x
K와 배열E의 엘리먼트간 비교연산이 베이직 오퍼레이션 . 이 부분 중요 ⭐️

따라서 알고리즘의 수행시간을 분석할때는 1번라인의 비교연산은 카운트하지 X
5, 7, 9번 라인을 고려한다. 
(9번의 else라인도 논리적으로 비교연산이 들어간다. K > E[mid])

한편, 점근적으로 분석하기 때문에 Input size n에 비례하게만 분석하면 된다.
따라서 3번의 비교연산(ppt에서 three-way-branch, 즉 5번라인 7번라인 9번라인, 즉 같다 , 크다, 작다  이 3가지의 비교를 비교연산으로 하고 있다.)
점근적으로 분석하기때문에 3번의 비교나 1번의 비교나 같다고 볼 수 있다.

따라서 워스트 케이스를 분석할때, three-way-branch는 한번의 비교라고 가정하고 분석한다.

첫번째 비교에서 재귀함수 호출을 위해 K!=E[mid]라고 가정. (워스트케이스기때문에)
그다음 2개로 섹션으로 나누어진다. n/2크기를 갖게됨. 
-> 비교할 엘리먼트의 수는 재귀적으로 절반씩 줄어든다.
이렇게 했을때 얼마나 많은 비교연산을 해야하는지 생각해보자.

입력의 사이즈로 n이 주어지고,
한번 재귀를 호출할때마다(바이너리서치함수를 호출할때마다) 1/2씩 줄어듬
n x 1/2 x 1/2 x 1/2 … x 1/2 = 1
-> 몇 번의 비교연산을 수행해야 사이즈가 1이되나?
워스트 케이스는 마지막에 1개의 엘리먼트가 남았을때 그때 비교를하면 최종적으로 알수가 있다.

따라서 재귀함수를 호출한 횟수가 몇번이냐, x번이라고 가정.
n * (1/2)^x = 1
……
-> x = log2(n) -> 재귀함수를 호출하는 횟수는 log2(n)과 비례하게된다.
엄밀히 말해서는 내림(바닥함수)를 수행한 횟수만큼 비교연산을 수행하게 된다.

그리고 한번의 비교연산이 더 있는데,
이는 재귀연산을 호출하기전에, 즉
8번라인과 10번라인을 수행하기전에 비교연산을 한 번 수행해야한다. 그거 1번.

따라서 
![알고리즘 3주차-2](images/알고리즘%203주차-2.png)

이다.

![알고리즘 3주차-2-1](images/알고리즘%203주차-2-1.png)

인 이유?

![알고리즘 3주차-2-2](images/알고리즘%203주차-2-2.png)

참고정도만..

결론 : 워스트케이스는 빅세타(log n) 이다.

47)
에버리지 케이스.

성공할 때 케이스 : n, 실패할 때 케이스 : n+1 (또는 다른관점에서는 1개의 case라고 볼 수 있다)

몇가지 가정을하고 분석한다.
1. 성공할때의 확률 (, 실패할때의 확률(?)) Pr(Ii | such) = 1/n
2. n = 2^d - 1 일때라고 가정 (비교연산을 가장 많이하는 케이스임) 이진트리로 생각했을 때 맨 아래 레벨까지 노드가 모두 꽉차있는 경우 perfect binary tree(또는 complete binary tree라고 하는 경우도 있음)
3. 저장되는 n개의 엔트리는 모두 다른값을 갖는다.

평균수행시간 = 성공확률*성공할때의평균수행시간 + 실패확률*실패할때의평균수행시간
![알고리즘 3주차-2-3](images/알고리즘%203주차-2-3.png)

증명내용 스샷참고

