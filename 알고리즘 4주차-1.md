# 알고리즘 4주차-1

48)
바이너리서치의 Optimality -> 워스트케이스에 대해서 분석하는 것.

문제의 복잡도를 살펴보자.

여기서, “Decision tree”를 이용한다(바이너리트리), 어떤 알고리즘에 대한 디시젼 트리.
알고리즘 A, 인풋사이즈 n에 대한 디시젼 트리.
아래 규칙에 의해 노드에 대해 label을 생성한다. index를 의미하는 label을 갖는 바이너리 트리라고 생각하면된다.
뭐 복잡하게 나와있는데, 복잡하게 생각안해도 된다..
여기서 바이너리 서치가 알고리즘 A가 된다.

처음 비교하는 인덱스가 root의 label이 된다. ( n/2 )
스샷 그림과 같이 재귀적으로수행. . .

리프노드(실패할시)는 따로 label이나 노드를 생성하지않음. 더이상 비교할 노드가 없을땐.

모든 가능한 케이스에 대해 나타낼 수 있다.

-> 문제의 복잡도는 이 decision tree를 이용할것.

49)
n=10 일때의 decision tree 예시

스샷참고

preorder traversal이라고 생각해도 됨.

+) strategy A, B(가장 왼쪽 엔트리부터 비교하는거)에 대한 decision tree 생성해보자. 스샷그림 참고
![알고리즘 4주차-1](images/알고리즘%204주차-1.png)

예)여기서, E[1]이 K보다 크던 작던, 다음에 비교할 인덱스는 1이다.
왜냐하먼 정렬된 배열이 아니기 때문~

외우려고하지말고 이해하는게 중요.
알고리즘이 어떻게 동작하는 지에 따라 decision tree의 모양이 달라진다~

50)
decision tree를 알았으니까 어떻게 decision tree를 이용해서 분석해보자.

longest path의 길이가 최악의 경우의 비교연산의 수가 된다.
= 최악의 경우에 필요한 최소 연산의 수
p : root부터 leaf의 깊이. longest path

N : decision 트리 노드의 개수, n : 인풋 사이즈

현재 알고리즘 A가 정확히 뭔지 모른다고 가정 
-> decision tree의 모양이 어떻데 되는지 모름  -> N개 노드라고 가정

루트부터 리프까지 가장 깊을 때를 p라고 했을 때,
최악의 경우 아무리 노드수가 많아야 perfect binary tree 모양이 된다.
그래서
![알고리즘 4주차-1-1](images/알고리즘%204주차-1-1.png)

N은 아무리 많아야 위와 같은 식이 된다.

다음로 증명해야할 내용은 N>=n 임을 증명하는것.
즉 decision tree 노드의 수 N은 인풋사이즈 n보다 크거나 같아야함을 증명해야함.
위에서 decision tree 를 그리며 증명했지만, N이 n보다 작을순 없나?!
N<n임을 모순법으로 증명해보자

51)
임의의 노드에 대한 label이 i(0<= i <= n-1)인 노드가 존재하지 않는다고 가정 (왜냐하면 N < n 이므로 어떤 노드는 존재하지 않을 수 있음)

배열 2개 E1, E2.
i번째 원소를 각각 50, 51이라고 하고 나머지 원소의 값들은 같다고 가정 (스샷참고)

-> input이 다름에도 즉 i번째에 있는 값이 다른데도 불구하고, 이 알고리즘은 같은 output을 출력할 것.

만약 E1[i] = K이고, E2[i] = K` > K 이라고하면,
두 배열의 output은 달라야하는데 i번째는 비교할 수 가 없으니까 … output이 같아진다.
-> 모순점.

따라서 N>=n이어야한다.

51)
따라서.
![알고리즘 4주차-1-2](images/알고리즘%204주차-1-2.png)

p는  logest path길이이자 최악의경우 필요한 최소 operation 수

p는 정수이므로, 최소
![알고리즘 4주차-1-3](images/알고리즘%204주차-1-3.png)

만큼의 연산이 필요하다. 어떤 알고리즘이더라도 최소한 이만큼의 연산 필요.

=>
알고리즘D(바이너리서치 알고리즘)가 optimal 알고리즘이다.

2장.
Data Abstraction and Basic Data Structures

2)
Abstract Data Type

Abstract = 요약.
어떤 데이터 타입에 대해 요약한 것.(개념적으로 이렇게 이해하면 되겠다.)

그 자료구조에서의 변수와 기능. Structures, Functions.
어떤 멤버변수, 멤버함수가 있느냐.
ADT는 하나의 Class라고 설명될 수 있다.

ADT는 어떤 input에 대해서 output이 나온다를 말하는 것. 자세한 과정이나 성능 얘기하지 않는다.
알고리즘의 correctness를 말하는것.
성능에 대해서 언급하는것은 x 동작과정 중요x

장점
알고리즘의 correctness와 성능(퍼포먼스)분석을 서로 다른 개념으로 생각할 수 있다.

ADT는 개발자의 측면과 사용자의 측면을 구분하는 것.
예) 우리가 어떤걸 구현하는 개발자라면,
c++를 사용한다면 stl이라는 라이브러리가 있을것(자바에서는 api)
이것을 사용하기때문에 사용자가 된다.
-> ADT는 사용자 관점에서 얘깋는 것.
어떤 input에 대해 output이 나오는 게중요하지, 어떻게 동작하는지는 중요하지 X

예) 선풍기.. 약풍 미풍 강풍 과 같은 output을 내는 기능이 있다.
사용자입장에서 내부적으로 어떻게 동작하는지 전혀 궁금치않음.

Performance analysis : 알고리즘의 성능을 분석하려면 그 알고리즘이 어떻게 구현되었나, 즉 implementation을 알아야한다. 복잡도. ADT와는 다른 내용이다.
성능에 대해서 분석하려면 구현방법에 대해 설명해야한다.

먼저 ADT를 말하고.. 그이후 각 operation 성능을 분석할 수 있다,,

