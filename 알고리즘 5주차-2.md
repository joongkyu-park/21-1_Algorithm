# 알고리즘 5주차-2

15)
인풋으로 O(n)스페이스를 사용하는데,
알고리즘에서 추가적으로 사용하는 메모리가 상수크기일때
(또는 log n 까지는 허용)
	-> in-place 알고리즘이라고함

퀵소트도 인플레이스로 구현가능

 
![알고리즘 5주차-2](images/알고리즘%205주차-2.png)

L : l~h-1
E : h~k
G : k+1~r
의 세 그룹으로 나눈다.

인풋으로 들어온 어레이 내에서 파티션을 수행할 수 있으므로, 인플레이스 퀵소트 알고리즘이라 부름
크게 다른건없음.

왜 log n 까지 허용할까
![알고리즘 5주차-2-1](images/알고리즘%205주차-2-1.png)

이렇게 재귀적으로 들어갔을때,
…

16)
인플레이션으로 파티션 했을 때 예시

왼쪽은 L그룹,
오른쪽은 E U G그룹으로 파티션

피벗은 랜덤하게 선택

j:가장 처음인덱스
k:가장 마지막인데스

j:피벗 값보다 같거나 큰 값을 찾을때까지 scan
k:피벗 값보다 작은 값을 찾을때까지 scan

-> 인덱스 j와 k의 값을 swap

이 작업을 계속 반복. 
j와 k가 만날 때까지 반복

마지막에 j와 k가 만날때,
그 인덱스 값과 피벗의 값을 스왑

17)
문제의 복잡도
n log(n) -> 이건 증명된 것. 여기선 따로 증명 x
이거와 같은 소팅
머지소트, 힙소트

18)
머지소트.
핵심전략 : 머지를 어떻게 하느냐
두개의 정렬된 시퀀스 A, B가 주어졌을때
이 두 시퀀스를 하나의 시퀀스 C로 머지를 해줌.
C도 역시 정렬이 되어있는 상태로.
	-> 이 전략이 머지소트의  핵심

여기서도 divide의 conquer전략 사용
combine단계에서 정렬함.

각 시퀀스의 가장작은값부터 비교해서 가장 작은 값부터 C에 채워넣는다.
이렇게 하면 오름차순으로 채울 수 있음.
![알고리즘 5주차-2-2](images/알고리즘%205주차-2-2.png)

19)
머지소트의 의사코드

두개의 엘리먼트간의 연산이 베이직오퍼레이션

최악의경우 : 번갈아가면서 채우는경우
마지막에 경우에 한쪽 배열은 원소가1개, 한쪽 배열은 원소가 0개이므로 비교연산x
-> 따라서 최악의 경우의 베이직오퍼레이션은 n-1 번 수행

20)
무조건 절반씩 파티션한다.

먼저 재귀적으로 파티션을 다하고, 
더이상 파티션할 부분이 없으면 재귀적으로 머지 진행.

퀵소트는 divide단계에서 정렬한다고 볼수 있고.
머지소트는 divide단계에서는 무조건 파티션만,
conquer와 combine이 동시에 된다고보면되는데, combine때 재귀가 풀리면서 머지진행

21) 
여기서 맨처음에 fisrt는 0, last는 n-1 이겠다

파티션하다가 원소가 각각 1개씩 되었을때는 정렬된상태로 볼 수 있기 때문에,
그때부터 역순으로 재귀가 풀리면서 머지진행

최악의경우의 수행시간을 다음과같이 점화식으로 만들수 있다.

원소의 개수가 1개일땐 더이상 비교하지않기 때문에 비교연산 = 0
	-> 재귀의 탈출조건
![알고리즘 5주차-2-3](images/알고리즘%205주차-2-3.png)

22)
힙소트를 살펴보자

23)
힙 자료구조는 다음과같은 조건을 만족시킨다.
구조조건 : complete binary tree
순서조건 : partial order tree property

*이 교재에서는 이진트리를 꽉채운걸 complete  binary tree라고 표현
그래서, h-1깊이까지 꽉차고 h깊이는 왼쪽부터 차근차근 노드가있는걸 left-complete binary tree라고 표현

partial order tree property
맥스힙이라고 가정했을때,
![알고리즘 5주차-2-4](images/알고리즘%205주차-2-4.png)

일 때
parent(v).key >= v.key
의 조건을 만족시켜줄 때 partial order tree property 라고 하낟.

결론적으로 힙에서는, 루트노드가 가장 큰 값을 갖는다.

24)
힙소트의 구조조건 및 순서조건을 만족시키는, 만족시키지 않는 예시
1번 : 구조조건X
2번 : 구조조건O
3, 4번 : 구조,순서조건 O-> heap O

25)
힙소트 전략

가장큰 값을 오른쪽부터 왼쪽방향으로 채워준다

힙에서 insert
upheap을 통해 leaf에서 루트까지 올라가는경우가 최악 -> O(lg n)

removemax
루트노드와 마지막 리프노드 값을 바꾸고, 리프노드 제거.
이후 루트노드에 대해 donwheap -> 최악의경우 O(lg n)

findmax
루트노드만 살펴보면됨. O(1)

26)
힙소트 아웃라인

정렬이된 n개의 엘리먼트 E로 heap H생성. bottom-up 방식을 이용하면 O(n)시간에 생성가능 (n개의 엘리먼트가 미리 주어지면)

따라서 힙 H를 contruct하는 건 O(n)에 수행.

i를 n부터 수행하는 이유는 array에 마지막부터 채워넣기위해.
여기선 인덱스가 1~n이라고 생각하면 된다.
왜냐하면 인플레이스로 수행하는데, 0번 인덱스는 빈자리로.
![알고리즘 5주차-2-5](images/알고리즘%205주차-2-5.png)

deleteMax
구조조건을 만족시켜주기 위해 마지막 노드의 값을 변수 k에 저장해놓고, 마지막노드삭제
![알고리즘 5주차-2-6](images/알고리즘%205주차-2-6.png)

여기서 fixHeap은 다운힙과같음 -> 순서조건

27)
fixheap 설명
매층 마다 2번의 비교연산을 하기 때문에,
최악의경우 높이만큼인 2log(n)만큼 연산.

28)
그림예시

