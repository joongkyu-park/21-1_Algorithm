# 알고리즘 6주차-1

29)

힙을 생성하는 방법.
힙은 linear time에 생성가능. -> n개의 엘리먼트가 인풋으로 들어와있어야가능.
n개의 엘리먼트가 1개씩 1개씩 삽입된다면 linear time에 불가능

H : 컴플리트 바이너리 트리의 구조적 조건만 만족시켜준 애

contructHeap : 바텀업 컨스트럭쳐

fix힙 -> 다운힙으로 순서조건 만족시켜줌

30)
순서 
![알고리즘 6주차-1](images/알고리즘%206주차-1.png)

복잡도 분석.

베이직 오퍼레이션이 제일 많이 일어나도록, 컴플리트 바이너리트리라고 가정(리프까지 꽉참)
왼쪽으로 한번 swap 그 이후 오른쪽으로 쭉 리프까지 swap연산 한다고 가정.

스왑연산을 세보자
노드개수가 n개라고 할때
리프노드의 개수는 대략 n/2개. 얘네는 스왑연산 없음.
그 위레벨은 대략 n/4개이고, 1번 스왑연산.
… 루트노드까지

베이직 오퍼레이션이 비교연산이기 때문에 비교연산도 살펴보자.
스왑 1번단 2번 비교연산. (자식끼리 먼저한번, 그리고 비교해서 큰 자식과 부모와 비교 한번)
 
![알고리즘 6주차-1-1](images/알고리즘%206주차-1-1.png)

![알고리즘 6주차-1-2](images/알고리즘%206주차-1-2.png)

따라서 힙을 생성하는 알고리즘은 선형시간에 바운드된다.

이 역시 디바이드-컨쿼 전략을 사용한다.

31)
힙을 꼭 링크드스트럭쳐가아니라 배열기반으로 구현할 수 도 있다.

인덱스 0은 사용 x

32)
힙소트 알고리즘 분석

힙소트는 removeMax를 n번해서, 오른쪽으로 채워나간다(오름차순이라면).
![알고리즘 6주차-1-3](images/알고리즘%206주차-1-3.png)

따라서 힙소트를 하는데 O(nlog(n))에 바운드 된다.

더 정확히 말하면
![알고리즘 6주차-1-4](images/알고리즘%206주차-1-4.png)

2nlog(n) : 정렬하는데 걸리는 시간
O(n) : 힙을 생성하는데 걸리는 시간
의 시간이 걸린다.

정렬하는게 걸리는 시간 2nlog(n)을 nlog(n)으로 만들어 줄 수 있다. 2배 빠르게

기본적인 힙소트 알고리즘도
문제의 복잡도와 같기 떄문에 옵티멀 알고리즘이다.

33)
그것이 Accelerated heap-sort.
약 2배정도 수행시간 개선가능.
결론적으로 fixheap을 개선시킬것
디바이드-컨쿼 전략을 사용하여.
바이너리서치와 뭔가 유사한 방법으로 개선시킴.(같진않다)

h/2 높이까지, 자식끼리와의 비교만하고 큰 자식과 무조건 swap.
h/2 높이에 왔을 때 부모와 비교하여 부모보다 크면, 위로올라감. -> 절반아래부분은 신경안써도됨
부모보다 작으면 아래로 내려감. 같은방법으로 재귀적으로 실행.(절반의 높이까지) -> 절반위부분은 신경안써도됨

34)
버블업힙

37)
알고리즘 수도코드

부모보다 크면 버블업힙수행(올라가는 함수) -> 최대 이전스텝에서 내려온만큼 올라갈 수 있음.
부도보다 작으면 재귀적으로 본인함수 수행, 프로모트함수로 내려감(내려가는 함수)

38)
프로모트 함수

35,36)
그림설명

힙은 당연힌 컴플리트 바이너리 트리여야함.
근데 그림은 설명에 필요한 영역만 보여준것.

내려갈때도 한번의 비교연산(자식끼리)
올라갈때도 한번의 비교연산(부모와)을 사용한다.

39)
비교연산(베이직오퍼레이션)을 많이 해봐야 h번.
	->이유 : h/2까지 내려오고, 버블업힙이면 최대 h/2번 더 해야함. -> h번 						프로모트(내려감)면 h/4까지 내려오고, 그때 다시 올라와야한다면 h/4번 						…
		=> 결국은 토탈 h번

최악의 경우는 버블업힙을 한번도 수행하지 않는 경우.
![알고리즘 6주차-1-5](images/알고리즘%206주차-1-5.png)

h에, 1/2h가 될때마다 parent와 비교하기 때문에 추가로 log(h)의 연산이 필요해서
![알고리즘 6주차-1-6](images/알고리즘%206주차-1-6.png)

총 h+log(h)연산 필요.

한번 removemin을 하면
한번 fixheapfast가 필요

n개의 엘리먼트라면, 힙소트를 위해 n번의 fixheapfast가 필요.
![알고리즘 6주차-1-7](images/알고리즘%206주차-1-7.png)

40)
이게 accelerated heapsort 의 수행시간.
![알고리즘 6주차-1-8](images/알고리즘%206주차-1-8.png)

-> 결국 최고차항이 2배 감소, 노멀힙소트보다 대략 2배 빨라졌다.

