# 알고리즘 7주차-1

시험범위는 6장까지. 1~6단원

6. 다이나믹 셋과 서칭
다이나믹 셋?
시간에 따라 데이터스트럭쳐의 크기가 커졌다, 작아졌다 할 수 있다는 뜻. 인서트와 딜리트로 인해.
그런걸 다이나믹 셋이라고 부름
이런경우 어떻게 분석하냐, 배운다

지금까지 워스트 케이스 어낼리시스, 애버리지 케이스 어낼리시스에서 배웠는데
새로 어모타이즈드 어낼리시스를 배운다

서칭
바이너리서치트리 언급하고
새로운 밸런스드 바이너리 서치트리로 레드블랙트리를 배운다.

2)
콘텐츠 

Amortized Analysis : 분할상환 분석방법

3)
array doubling
어레이는 임의의 인덱스에 상수시간에 접근할 수 있다.
단점은 고정된 사이즈로 할당해줘야한다는 점. (링크드리스트에 비해)
->얼마나큰 어레이가 필요한지 예측하기 어렵다.

따라서 넉넉한 어레이를 할당할것인데,
새로운 엘리먼트를 인서트했을 때 공간이 부족할 수 있다.
-> 공간이 2배인 새로운 어레이를 할당해주고, 새로운 어레이로 엘리먼트들을 transferring 해주는것
이것이 어레이 더블링.
![알고리즘 7주차-1](images/알고리즘%207주차-1.png)

n번의 transferring과
1번의 insert (새로 넣고싶은 n+1번째 엘리먼트는 삽입)

하나의 엘리먼트를 트랜스퍼링하는데 t의 cost가 든다고할 때
t*n의 비용이 든다고 하자.
이럴때 worst case인 경우 한 번의 insert에 수행시간은?
O(tn) time (if t : constant) -> O(n) time
![알고리즘 7주차-1-1](images/알고리즘%207주차-1-1.png)

평상시 어레이더블링이 발생하기전에는 insert가 상수시간에 처리될 수 있다.
더블링이 발생할때만 1개의 엘리먼트를 insert하는데 O(n) time이라는 많은 시간이 걸린다.
-> 따라서 워스트케이스가 이렇기때문에.. 1개를 insert하는데 O(n)time이라고 말할 수 밖에 없다.
-> 이럴때 워스트케이스를 분석하는 것은.. 합리적이지 않다. 틀린말은 아니지만..
거의다 상수시간걸리는데 가끔 한번 O(n)time 걸린다고..
=> 이 때 합리적으로 분석하는 방법이 Amortized analysis이다.

우선 워스트케이스에 대해 분석을 한다.
차이점은 연산이 연속적으로 발생에 한다.
이 연속적으로 발생하는 연산에 대해서 해당 연산에 대한 최악의 경우의 평균비용을 계산한다.
평균비용이란, 비용에 대한 평균임. (에버리지 케이스는 수행에 대한 평균. 알고리즘이 어떻게 수행될 것이냐)
즉 워스트케이스에 대해 분석하지만, 비용에 대해 평균이다.

average case analysis와 Amortized analysis 와 차이점.
에버리지 케이스 에선 확률의 개념이들어가고,
어모타이즈에선 확률의 개념이 들어가지 않는다.

어레이더블링을 하게될때 드는 트랜스퍼링에 대한 코스트를 살펴보자.
총 t*n
이전의 코스트도 살펴보자.
사이즈 n/2이었을때 ->n으로 되었을때 트랜스퍼링 코스트는?
n/4이었을때?
…
이걸 다 더해보자.
![알고리즘 7주차-1-2](images/알고리즘%207주차-1-2.png)

처음 어레이사이즈가 1부터 시작했다고 가정.
정리하면,
![알고리즘 7주차-1-3](images/알고리즘%207주차-1-3.png)

따라서 기존의 사이즈가 n/2, n/4, … 이었을 때의 트랜스퍼링 비용은 총합이 t*n을 넘지 않는다.

따라서 토탈코스트는 2t*n을 초과하지않는다. (n일때의 트랜스퍼링비용 + 이전의 트랜스퍼링 비용, 각각 t*n)
![알고리즘 7주차-1-4](images/알고리즘%207주차-1-4.png)

그런데, 여기서의 “2t”가 중요한 의미를 갖는다. 뒤에서 다룬다.

4)
Amortized analysis
연속적으로 오퍼레이션이 발생하는데, 워스트케이스에 대해.
각 연산의 비용의 평균을 분석할 수 있다.

워스트케이스와 구분하기위해, amortized ~~ 시간이다 라고 표현한다.

어모타이즈 어낼리시스도 크게 3가지 방법이 있다.
1. aggregate method 발생했던 연산의 비용을 그냥 다 더해서 평균낸다.
2. accounting method⭐️ 이게 우리가 강의시간에 다루는거
3. potential method

![알고리즘 7주차-1-5](images/알고리즘%207주차-1-5.png)

어카운팅 메소드.
한 마디로 평상시에 적은 비용을 사용하다가 특별한 경우에 큰 비용이 들어갈 때, 어모타이즈 어낼리시스를 한다.
어카운팅은 목돈이 들어가는 때에 대비해 미리 저축하는 방식이다, 라고 생각하면 된다.
![알고리즘 7주차-1-6](images/알고리즘%207주차-1-6.png)

식비에 비유한 예시.
평소엔 식비를 1만원쓰다가 한달에 한번 10만원쓴다
그 날을 대비해서 하루에 3300원씩 모은다고 생각하고,
1만원을 actual cost, 3300원을 accounting cost
둘이 합한걸 amortized cost라고 부른다.

연산에 대한 분석이기때문에, 연산마다 다른 accounting cost를 할당해줄 수 도 있다.
그러나 연산마다 독립적으로 accounting cost를 할당하는 것은 같다.
accounting cost를 설정할 때 유의할점.
1. accounting cost의 sum이 음수이면 안된다. 왜 음수를 걱정하냐. 목돈을 쓰는 날에 저축된 돈을 빼는데, 그 때도 잔액이 0보다 커야한다는 비유. 음수가 발생하면 적자가 계속 발생하니까..
2. amortized cost를 분석하기 용이한 값으로 세팅해준다.

앞에서 얘기했던 “2t”가 중요한 역할을 수행하게 된다.
결론부터 말하면 accounting cost로 2t를 세팅해준다.
한번 연산이 발생할때마다 2t를 저축해주면 음수가 되지 않는다는 뜻

5)
어레이 더블링을 이용해서 스택을 구현한다고 해보자

push와 pop이 발생하는데, 각각 비용이 1이라고(constant)라고 가정. 더블링이 발생하지 않을 때.

더블링이 발생할 때는 현재 사이즈가 n이라고 했을때 t*n의 트랜스퍼링비용, 1번의 푸시비용 1
총 1+t*n
![알고리즘 7주차-1-7](images/알고리즘%207주차-1-7.png)

이번엔 actual이 아니라 accouting cost 측면에서 보자.
어카운트를 2t로 해주면 잔액이 음수가 발생되지않는다.

따라서 평상시 푸쉬할때 2t를 저축
더블링이 발생할때 은행계좌에서 -t*n 해주고(트랜스퍼링비용차감) 그리고 2t도 저축 (1번 푸쉬하니까)

amortize cost 는 
평상시에 1+2t
더블링이 발생할때도 (1+t*n) + (-t*n + 2t)이므로 1+2t

따라서 푸쉬연산에 대한 amortize cost는 1+2t이다.
-> 어카운팅 코스트를 2t로 하면 어카운팅 코스트의 sum이 음수가 되지 않는다! 더블링시 차감을 해줘도 커버가 된다.

항상 푸쉬연산만 발생했을때가 worst case기 때문에 (어레이 더블링이 가장 많이 발생할때) 푸쉬연산만 생각.

스택이 생성될때부터 어카운팅 sum은 negative가 되면 안된다. 0은 가능.

=> 1+2t이기 때문에 t가 constant면 상수시간에 insert를 수행해주게 된다. O(1) time
그냥 상수시간이라고 하면안되고, Amortized O(1) time이라고 이야기해야한다. (t가 constant 일 때)
![알고리즘 7주차-1-8](images/알고리즘%207주차-1-8.png)

6)
다음.

7)
바이너리 서치 트리에 대해 먼저 설명.
binary search tree.

바이너리 서치 vs. 바이너리 트리 vs. 바이너리 서치 트리 ?
![알고리즘 7주차-1-9](images/알고리즘%207주차-1-9.png)

- 바이너리 서치 서치이기 때문에 이진탐색 알고리즘
- 바이너리 트리, 바이너리 서치트리 -> 자료구조

바이너리 서치트리는, 우선 바이너리 트리를 만족함. 
	바이너리 트리 : 자식의 수가 많아야 2인 트리
여기에다가 추가적으로 1개의 프로퍼티 추가가된다.
노드의 key값에 의해 순서조건이 있다.
이런걸 바이너리서치트리라고 한다.
그러한 순서조건을 바이너리 서치 트리 프로퍼티 라고한다.

순서조건은 그럼뭐냐,
![알고리즘 7주차-1-10](images/알고리즘%207주차-1-10.png)

이 조건을 만족 시켜줘야한다.

이 조건을 만족시키는 바이너리트리를, 바이너리 서치 트리라고 한다.
개념상으로는 이 조건을 만족시켜주면 되고,

여기에서는 구현 방식에 따라, 즉 키값이 같을때
![알고리즘 7주차-1-11](images/알고리즘%207주차-1-11.png)

![알고리즘 7주차-1-12](images/알고리즘%207주차-1-12.png)

이렇게 처리를 해주겠다고 한다.

바이너리서치트리에 대해 inorder traversal을 하면
트리에 대한 키값을 오름차순으로 정렬된 결과를 얻을 수 있다.

8)
바이너리 서치 트리 예시.
둘다 바이너리 서치 트리인데, 하나의 차이점이 degree의 balanced된 정도가 다르다는 것.
아이템의 개수도 같고 키값도 같은데!
-> 삽입되는 순서에 따라 이런 차이가 생길 수 있다.

검은점은 leaf node를 의미한다.

탐색시간은 트리의 height에 따라 최악의수행시간이 달라지므로,
따라서 밸런스드 된 바이너리서치트리를 만들어줘야하고,
그 방법이 레드블랙트리.

여기까지.

