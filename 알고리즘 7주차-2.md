# 알고리즘 7주차-2

9)
바이너리 서치 트리에서의 탐색 알고리즘
파라미터는 바이너리서치트리, 찾을 키값

작으면 왼쪽서브트리로 가고, 크면 오른쪽 서브트리로 가고
ex) 왼쪽서브트리로 간다는 뜻은 오른쪽 서브트리는 더이상 가지않는다는 뜻.
이런 흐름적인 측면에서 바이너리 서치와 유사하다.
그러나 바이너리서치트리처럼 정확히 절반을 지우고 그러진 않음.

10)
bst에 n개의 노드가 저장되있다고 가정하자. 인터널노드의 개수. (leaf노드의 nil은 포함x)
수행시간은 트리의 height에 의해서 결정되는데,
최악의경우, 
![알고리즘 7주차-2](images/알고리즘%207주차-2.png)

이런 모양을 가지게 되었을 때
-> 세타오브 n time.
트리의 height만큼 시간걸린다.

언제 이런일이생기냐..
키값들이 오름차순 또는 내림차순으로 정렬된 상태에서 삽입이 발생할때.

트리의 밸런스가 맞다면, 컴플리트 바이너리 트리의 모양이 될것이고
세타오브 log(n) time에 바운드가 될것이다.
=> 따라서 우리는 bst가 밸런스를 갖도록 만들어 주는 것이 목표이다.

11)
그러한 방법중에 하나인 (밸런스드 바이너리 서치 트리를 만드는 방법)
height가 O(log n)에 바운드 되는 그런 바이너리 서치트리

레드블랙트리

다음 추가적인 4가지 성질을 만족시키는 바이너리 서치 트리이다.
모든 노드는 컬러값을 갖는 데이터를 갖는다.
- 루트 프로퍼티 루트는 블랙컬러
- external 프로퍼티 모든 리프들은 블랙컬러
- internal 프로퍼티 어떤 노드의 컬러가 레드인경우, 레드노드의 자식은 블랙
- depth 프로퍼티 모든 리프노드는 같은 black depth를 갖는다. 블랙댑스?  블랙노드에서 부모로 향하는 엣지를 블랙엣지 라고 부르는데, 루트부터 해당 노드까지의 패스상에 있는 블랙엣지의 수  이 말은 즉 리프노트부터 경로상의 루트노드를 제외한, 블랙노드의 수가 같다.

12)
n개의 아이템을 저장하는 레드블랙트리는 height가 O(log n)에 바운드 된다.
-> 이는 인터널프로퍼티(레드노드의 자식은 블랙이다)때문에 밸런스드 된다.
이것에 대해 직관적으로만 설명.
![알고리즘 7주차-2-1](images/알고리즘%207주차-2-1.png)

모든 리프중에서 가장 짧은 뎁스(블랙뎁스)를 가진 애는 블랙노드로만 구성된 경우일테다. (가능한진 모르겠지만 일단 이론상)
또 가장 긴 뎁스를 가진 경우는 블랙과 노드가 번갈아서 나타날 경우겠다.

이를 complete binary tree의 모양과 비교하면,
파랑색을 컴플리트 바이너리 트리라고 했을때
블랙노드로만 구성되는 패스의 뎁스는 컴플리트 바이너리트리보다 더 짧고, 
번갈아가며 나타나는 패스의 뎁스 더 길다.

번갈아가면서 나타나는 쪽의 뎁스는 블랙만 나타나는 쪽보다 최대 2배이상 차이가 날 수 없다.
가장 짧은거와 가장 긴거의 뎁스차이가 많이 차이나 봐야 2배차이.

트리의 height가 O(log n)에 바운드되어, 탐색도 O(log n)에 바운드 되게 수행할 수 있다.

13)
탐색알고리즘은 따로 설명 안함.
또 삭제알고리즘은 복잡해서, 본강의에서는 삽입만 다루겠다.

삽입 알고리즘
키를 아이템형식으로 (k, o)처럼 키와 엘리먼트(또는 키와 밸류)형태로 삽입한다. 딕셔너리 adt.
허나 설명의 편의상 엘리먼트는 존재하지 않는다고 가정.

삽입시 키값을 이용해서(바이너리서치트리의 순서조건을 만족시켜기위해) 자기위치를 찾고
일단 빨간색으로 삽입.
예)
키값이 4인 노드를 삽입한다고하자.
바이너리서치트리 탐색처럼 일단 자기 위치를 찾아간다.
그러고 컬러를 빨강색으로 삽입. (딸려있는 리프노드는 당연히 블랙)

그렇다면
![알고리즘 7주차-2-2](images/알고리즘%207주차-2-2.png)

왜 이렇게 삽입 해주냐..
알고리즘의 설계측면도 살펴보자. 왜 만든사람들은 이렇게 삽입을 했을까

->이렇게 했을때 레드블랙트리의 4가지 프로퍼티를 쉽게 만족시켜줄 수 있기 때문

empty 트리였다고 하더라도, 일단 저렇게 삽입하고
간단하게 루트임을 확인해서, 루트가 맞다면 블랙으로 업데이트 시켜주면 된다.
-> 루트 프로퍼티 만족

리프노드를 블랙노드로 달아줄거니까
-> 익스터널 프로퍼티 만족

패스상의 블랙노드 수는 여전히 같으므로
-> 뎁스 프로퍼티 만족 

그러나 인터널 프로퍼티를 만족해주는지 체크해줘야한다.
(레드노드의 자식은 블랙이다.)

삽입하고나서 만약 패런트의 노드 컬러가 블랙이다, 그러면 삽입바로끝
그러나 패런트의 노드 컬러가 레드이다 -> 더블레드가 발생했다하고, 재구성필요

14)
더블레드 발생시 재구성 방법. 처리방법.

패런트를 v, 자식노들 z, v의 sibling node(또는 z의 uncle node)를 w라고 하자.
w가 블랙이냐, 레드냐에 따라 다르게처리

w:블랙 -> restructuring
w:레드 -> recoloring

15)
restructuring
z, v, v의 패런트(z의 그랜드패런트) 이 3개의 노드에 대해 구조를 바꾸어준다.
-> 키값이 중간인애를 패런트로, 키값에 따라 나머지 노드를 레프트차일드, 라이트차일드로 놔준다.
![알고리즘 7주차-2-3](images/알고리즘%207주차-2-3.png)

색깔은,
재구성한 패런트는 블랙으로, 자식들은 레드로

한번만 수행하면 끝.

16)
리스트럭쳐가 발생할수있는 4가지 케이스

또 하나 유의할것이 서브트리들을 어떻게 처리할거냐가 포인트.
-> 재구성이후 그냥 순서대로 붙여준다.
![알고리즘 7주차-2-4](images/알고리즘%207주차-2-4.png)

-> 왜? 이렇게 순서대로 연결시켜줘야 bst의 순서조건을 만족시키기 때문

상수 번의 연산, O(1)타임에 리스트럭쳐링이 가능하다.

17)
Recoloring
간단함.

v와 w의 컬러를 black으로 바꾸어주고, z의 그랜드패런트(v의 패런트)를 레드로 바꿔준다.
이렇게 해도 뎁스프로퍼티는 유지된다.
임의의 패스상의 블랙노드의 개수는 1개로 그대로 유지되기때문

이것역시 상수시간에 처리할 수 있다.

한 편 그랜드컬러가 레드로 바뀌었다.
-> 그래서 그랜드패런트 노드에서 double red 문제가 발생할 수도 있다.
그렇다면 같은 방법으로 더블레드 문제를 해결해주면 된다.

18)
삽입연산에 대한 분석을 정리해보자

삽입은 크게 3가지 스텝

step1.
삽입될 적절한 위치를 찾아가는것.
마치 탐색알고리즘과 유시하게 k값의 적절한 위치를 찾아준다.
-> O(log n)

step2.
찾은 위치(리프 노드 z)에
![알고리즘 7주차-2-5](images/알고리즘%207주차-2-5.png)

이런 형태의 노드 추가
-> O(1) time

step3.
더블레드를 처리
z노드의 엉클노드의 색깔에 따라 리스트럭쳐링 또는 리컬러링 (각각은 O(1) time)
-> 최악의 경우에 recoloring으로 루트노드까지 계속 수행할수도
-> O(log n) time

19)
예시

![알고리즘 7주차-2-6](images/알고리즘%207주차-2-6.png)

이 경우 더블레드 문제가 발생하는데, 엉클이 red이므로 recoloring 진행
그러나 그랜드패런트가 root이므로 레드로 바꿔주지 않는다.

20)
예시 계속
![알고리즘 7주차-2-7](images/알고리즘%207주차-2-7.png)

이 때 새로 삽입된 노드 14의 엉클이 리프노드, 즉 블랙노드이므로 restructuring

뒤예시 계속.
복습해라 알아서.

